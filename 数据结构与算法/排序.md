# 排序算法

讨论各种排序算法的实现，改进，复杂度（最好，最坏，平均，摊还），应用等。

时间复杂度：最好情况，最坏情况，平均情况。摊还时间复杂度。

空间复杂度：是否是原地排序（O(1)）。

排序算法的稳定性：如果排序后，相等元素的顺序保持不变，则该排序算法是稳定的。

## 插入排序

原地排序，稳定，平均时间复杂度O(n^2)

把数据区间分为已排序区间（初始为第一个元素）和未排序区间。

插入算法：取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入。重复这个过程，直到未排序区间中元素为空。 

```java
// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

### 选择排序：

在未排序区间钟，每次选最小的元素，放到已排序区的末尾。不稳定。

### 改进的插入排序：折半插入排序，希尔排序。

### 折半插入排序：

结合二分查找

```java
void BlnInsertSort(int a[], int len){
    int i, temp, j;
    for (i = 1; i < len;i++)
    {
        temp = a[i];　　　//将要插入的元素拷贝一份
        int low , high,mid;
            low = 0, high = i-1;
            while (low <=high)　　//在［ｌ．．．ｈ］　中寻找插入的位置
            {
                mid = (low + high) / 2;  //折半
                if (mid <= temp)
                {
                    low = mid+1;     //插在高半区 
                }
                else{
                    high = mid-1;    //插在低半区
                }
            }
            for (j = i - 1; j >= high + 1;--j) //腾出high+1的位置
            {
                a[j + 1] = a[j];   //记录后移
            }
            a[j + 1] = temp;
    }
}
```

### 希尔排序：

待补充

## 冒泡排序

原地排序，稳定，平均时间复杂度O(n^2)

一般冒泡排序

```java
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;

 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

鸡尾酒排序

```python
def cocktail_sort(num_array):
    left, right = 0, len(num_array)-1
    left_new, right_new = left, right  # 记录未交换边界
    unsorted = True

    while left < right:
        if unsorted:
            for j in range(left, right):
                unsorted = False
                if num_array[j] > num_array[j+1]:
                    num_array[j], num_array[j+1] = num_array[j+1], num_array[j]
                    unsorted = True
                    right_new = j
            right = right_new
            for j in range(right, left, -1):
                unsorted = False
                if num_array[j] < num_array[j-1]:
                    num_array[j], num_array[j-1] = num_array[j-1], num_array[j]
                    unsorted = True
                    left_new = j
            left = left_new
        else:
            break

```



## 快速排序

原地排序，不稳定，O(nlogn)

```
平均情况下：T(n)=2*T(n/2)+n;      第一次划分
      =2*（2*T(n/4)+n/2）+n;     第二次划分  (=2^2*T(n/4)+2*n)
      =2*(2*(2*T(n/8)+n/4)+n/2)+n;     第三次划分(=2*3*T(n/8)+3*n)
      =.....................
      =2^m+m*n;  第m次划分

因为2^m=n,所以等价于 = n+m*n
所以m=logn，所以T(n)=n+n*logn;   
```

数组的快速排序

```c++
void quick_sort()
```

链表的快速排序

```c++
struct Node {
	int data;
	struct Node* next;
	Node(int d):data(d), next(nullptr){}
};

void quick_sort_list(Node* start, Node* end=nullptr){
	if (start == nullptr || start == end) return;
	
	Node* p1 = start;
	Node* p2 = start->next;
	
	while (p2 != end) {
		if (p2->data < start->data) {
			p1 = p1->next;
			swap(p1->data, p2->data);
		}
		p2 = p2->next;
	}
	swap(p1->data, start->data);
	
	quick_sort_list(start, p1);
	quick_sort_list(p1->next, end);
}
```



## 归并排序

空间复杂度O(n)，稳定，时间复杂度和快速排序一样。

## 拓扑排序

## 堆排序

## 计数排序

## 基数排序