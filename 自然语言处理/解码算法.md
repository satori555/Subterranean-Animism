# 解码算法

束搜索（beam search）属于贪心算法，不一定能找到全局最优，但效率很高。

维特比（Viterbi）算法属于动态规划，常用于词性标注问题（状态数较少）。

维特比算法有最优解的前提是每一步是条件独立的（马尔可夫性），相当于2-gram。束搜索时后面的概率依赖于前面所有的词，相当于n-gram。



### 维特比算法

隐马尔可夫模型：
$$
\begin{align}
x_1,x_2,...,x_N
&= \arg\max P(x_1,x_2,...,x_N|y_1,y_2,...,y_N)\\
&= \arg\max \prod^N_{i-1}P(y_i|x_i) \cdot P(x_i|x_{i-1})
\end{align}
$$
设输入序列为 $y_1,...,y_N$，它们产生的隐含序列为 $x_1,...,x_N$。例如输入 $y$ 是拼音，输出 $x$ 是对应的汉字。

维特比算法（动态规划）：设 $x_{ij}$ 为状态 $x_i$ 的第 j 个可能取值，则问题转化为一个篱笆网络的最短路径问题。网络一共有 N 层，每层的可能状态有 D 种，D 为字典大小。

+ 第 1 层：$x_{11},x_{12},...,x_{1D}$

+ ...

+ 第 N 层：$x_{N1},x_{N2},...,x_{ND}$

转移公式，设起点为 S，从 S 到 第 i 个状态 $x_i$ 的最短距离为：
$$
d(S,x_{ij})=\min_{k\in D}[d(S,x_{i-1k})+d(x_{i-1k},x_{ij})]
$$

因为每一层只和前一层有关，需要计算 $D^2$ 次，一共有 N 层，时间复杂度为 $O(ND^2)$。

### 束搜索

假设词表大小为 3（a，b，c），beam size = 2，解码时，贪心算法每次只生成概率最大的词，束搜索（beam size = 2），每次记录概率最大的两个词。

1. 生成第一个词，假设概率最大的是 a 和 c，则当前序列为 a 和 c 。
2. 生成第二个词，将当前序列 a 和 c，分别于词表中的词组合，得到 3*2=6 个序列 aa ab ac ca cb cc，计算每个序列的得分，记录分数最高的两个序列，如 ac cc。
3. 重复这个过程，最终输出分数最高的两个序列。



参考：

[1] seq2seq 中的 beam search 算法过程是怎样的？ - 知乎
https://www.zhihu.com/question/54356960