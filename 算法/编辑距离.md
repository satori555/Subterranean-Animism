# 编辑距离（Edit Distance）

编辑距离指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。

根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。

例如，`mitcmu` 和 `mtacnu` 的莱文斯坦距离是 3 ，最长公共子串长度是 4 。



### 莱文斯坦距离（Levenshtein distance）

莱文斯坦距离允许增加、删除、替换字符这三个编辑操作。

如何求解两个字符串 a 和 b 的莱文斯坦距离？

##### 回溯法：

如果 `a[i]` 和 `b[j]` 匹配，我们递归考察 `a[i+1]` 和 `b[j+1]` 。

如果不匹配，再考虑以下情况：

+ 删除 `a[i]` ，然后递归考察 `a[i+1]` 和 `b[j]` 
+ 删除 `b[j]` ，然后递归考察 `a[i]` 和 `b[j+1]` 
+ 在 `a[i]` 前面添加一个和 `b[j]` 相同的字符，然后递归考察 `a[i]` 和 `b[j+1]` 

+ 在 `b[j]` 前面添加一个和 `a[i]` 相同的字符，然后递归考察 `a[i+1]` 和 `b[j]` 
+ 将 `a[i]` 替换成 `b[j]` ，或者将 `b[j]` 替换成 `a[i]` ，然后递归考察 `a[i+1]` 和 `b[j+1]` 

##### 动态规划：

把 `a[i]` 和 `b[j]` 的距离记作 `min_edist(i,j)` ，写出状态转移方程：

```
如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)

如果：a[i]==b[j]，那么：min_edist(i, j)就等于：
min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))
```



### 最长公共子串长度（Longest common substring length）

问题：

给定两个字符串，求解这两个字符串的最长公共子序列。比如字符串1：BDCABA；字符串2：ABCBDAB。则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA

思路：

设 $X=(x_1,x_2,.....x_n)$ 和 $Y=(y_1,y_2,.....y_m)$ 是两个序列，将 X 和 Y 的最长公共子序列记为 LCS(X,Y) 

考虑以下情况：

1. 如果x_n = y_m，则 $LCS(x_n,y_m)=LCS(x_{n-1},y_{m-1})+1$
2. 如果x_n != y_m，则 $LCS(x_n,y_m)=\max\{LCS(X_{n-1}，Y_m)，LCS(X_n，Y_{m-1})\}$ 



参考：求解两个字符串的最长公共子序列 - hapjin - 博客园
https://www.cnblogs.com/hapjin/p/5572483.html