# 哈希表（Hash Table）

哈希表，又叫散列表。

我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

### 散列函数 hash(key)

散列函数设计的基本要求：

1. 散列函数计算得到的散列值是一个非负整数。
2. 如果 key1 = key2，那么 hash(key1) == hash(key2)
3. 如果 key1 != key2，那么 hash(key1) != hash(key2)

### 散列冲突

开放寻址法（open addressing）和链表法（chaining）。

开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。方法包括：线性探测，二次探测和双重散列。

1. 线性探测。如果经过散列函数后，存储位置被占用了，就从当前位置向后查找，直到找到为止。即探测下标序列为 hash(key)+0，hash(key)+1，hash(key)+2……
2. 二次探测。相比线性探测，步长变成平方，即  hash(key)+0，hash(key)+1，hash(key)+4……
3. 双重散列。使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……如果第一个散列函数得到的位置被占用，再用第二个，以此类推。

当散列表中空闲位置不多时，散列冲突的概率就会大大提高。我们用装载因子（load factor）表示空位的多少。

链表法是更加常用简单的方法。在散列表中，每个位置对应一条链表，插入时将数据插入到对应链表中。链表比较长的时候还可以改成跳表或红黑树。